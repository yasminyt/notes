## 写大数据
+ 在 js 中，为了表达大的数据，通常用 **" e "** 来表示这个数中有多少个零
+ 有多少个零需要表示，就在 **" e "** 后用整数表示
  ```javascript
  alert( 7.3e6 )  // 7.3 * 1,000,000 = 7,300,000
  ```
+ 在 **" e "** 后用负整数表示小数
  ```javascript
  alert( 7.3e-6 )  // 7.3 * 0.000001 = 0.0000073
  ```

## toString(base)
+ `num.toString(base)` 方法可以返回给定的 `num` 按照对应进制 `base` 的字符串数据
  ```javascript
  let num = 255

  alert(num.toString(16)) // ff
  alert(num.toString(2))  // 11111111
  ```
+ `base` 可以是 2～36 之间的数，默认是 10，常用的有以下几种：
  + **base = 16** 用于十六进制颜色、字符编码等，数字可以是 0～9 或 A～F
  + **base = 2** 主要用于调试按位操作，数字可以是 0 或 1
  + **base = 36** 是最大值，数字可以是 0—9 或 A-Z。当需要将一个较长的数字标识符变成较短的时候，例如做一个简短的 URL，可以通过用基数为 36 的数字系统表示：
    ```javascript
    alert(12345..toString(36))   // 2n9c
    ```
+ 如果直接在一个数字上调用一个方法（如上代码所示 `12345..toString(36)`），则需要**在数字后面加两个点**。也可以写成 `(12345).toString(36)`
  + 因为 js 认为第一个点代表了这个数的小数部分，如果这个数是一个整数，而没有小数部分，只加一个点，会被认为当成是小数部分进行处理，从而报错。
  + 所以需要再多加一个点，以告知是调用方法。


## 四舍五入
+ **Math.floor**
  + *向下舍入*：3.1 -> 3，-1.1 -> -2
+ **Math.ceil**
  + *向上舍入*：3.1 -> 4，-1.1 -> -1
+ **Math.round**
  + *向最近的整数舍入（四舍五入）*：3.1 -> 3，3.6 -> 4，-1.1 -> -1（负数的四舍五入不用理负号，只看数字部分按四舍五入来就好）
+ **Math.trunc (IE 不支持）**
  + *删除小数点后的所有内容而不舍入*：3.1 -> 3，-1.1 -> 1
+ 几种方法之间的比较：

  | | **Math.floor** | **Math.ceil** | **Math.round** | **Math.trunc** |
  | ------ | :------: | :------: | :------: | :------: |
  | 3.1 | 3 | 4 | 3 | 3 |
  | 3.6 | 3 | 4 | 4 | 3 |
  | -1.1 | -2 | -1 | -1 | -1 |
  | -1.6 | -2 | -1 | -2 | -1 |

+ 如果要将指定的小数按位数进行舍入，如 1.2345 保留两位小数，得 1.23，则可以通过两种方式来做：
  + *乘法和除法*
    ```javascript
    let num = 1.23456

    alert( Math.floor(num * 100) / 100 )  // 1.23456 -> 123.456 -> 123 -> 1.23
    ```
    + 由以上代码可以看到，需要保留小数点后第几位，则先乘以对应有多少个 0 的整十、整百、整千等数，再通过 `Math.floor()` 将其余的小数去掉，再对得到的结果除以对应的乘的数，从而得到结果
  + **toFixed(n)** 将小数按给定的位数 **n** 进行四舍五入，并返回结果的**字符串**表示
    ```javascript
    let num = 12.34
    alert( num.toFixed(1) )   // "12.3"
    ```
    + `toFixed()` 的结果为一个字符串，如果小数部分比所需要的短，则在结尾处用 0 补足
    + 可以使用 *一元加号（+）* 或 *Number()* 将结果转换为数字：`+num.toFixed(5)  // 12.34000` 

## 精度损失
+ 数字是以 64 位格式进行存储，其中，52 位用于存储整数部分，11 位用于存储小数部分（如果是整数，则用 0 来填充），1 位是符号位
+ 当进行**两个小数**进行运算时，容易发生精度损失的问题
  ```javascript
  0.1 + 0.2   // 0.30000000000000004
  0.1 * 0.1   // 0.010000000000000002
  ```
+ 原因：一个数字是以二进制的形式存在在内存中，也就是说只是一系列的 0、1 指令。但是小数在计算过程中，会先将 十进制的小数 转换为 二进制，但是这个转换过程是一个无限不循环的过程，也就说得到的是一个无限不循环的数，所以计算机为了将这串数存储到内存中，丢失了一部分精度。在计算过程中，同样也会发生这样的情况
+ 所以对于小数运算的结果，不要直接作相等比较
+ 通常是通过 `toFixed(n)` 方法来对小数位数进行保留，来解决这个问题
+ 另外，内存中对于 0 和 -0 是分别存储的，但是操作过程中，会认为二者是相等的，所以不用特别考虑

## isFinite & isNaN
+ 有两种特殊的数值：
  + **Infinity（-Infinity）**：正无穷、负无穷
  + **NaN**：代表了一个错误
+ **`isNaN(value)`**：将 value 转换成一个 number，然后测试转换后的结果是否为 NaN
  + **NaN** 是一个特殊的值，不等于其它任何值，包括它本身
    ```javascript
    NaN === NaN   // false
    ```
+ **`isFinite(value)`**：将 value 转换成一个 number，如果它是一个正常的数值，则返回 true，如果是 NaN / Infinity / -Infinity，则返回 false
  + 通常可以用来检测一个 value 是不是 Number 类型
  + 对于 空串/只有空格的字符串，都会被视为 0，所以返回的结果为 true
    ```javascript
    isFinite('')      // true
    isFinite('  ')    // true
    ```

### 用 Object.is 进行比较
+ 内置函数 `Object.is(value1, value2)` 可以用来对 value1 和 value2 进行比较，相当于 `===`
+ 但是对于以下两个特殊例子，该函数的结果与严格比较的结果正好相反
  + 认为两个 NaN 是相等的：
    ```javascript
    Object.is(NaN, NaN)   // true

    NaN === NaN           // false
    ```
  + 认为 0 和 -0 是不相等的：
    ```javascript
    Object.is(0, -0)   // false

    0 === -0           // true
    ```
+ 除了以上两个特殊的情况外，其表现与严格比较一致


## parseInt & parseFloat
+ 将字符串转换成数字 可以用 一元运算符（+）或者 `Number(str)`，但是二者都是严格转换的，也就是说只能是一个整数或小数的字符串
  ```javascript
  Number('100px')   // NaN
  ```
+ `parseInt(str)` 和 `parseFloat(str)` 则提供了一个比较宽松的匹配，对字符串进行相应的匹配，当发现第一个不匹配的字符时则停止
+ `parseInt(str)` 返回的是一个整数，即便有小数部分，也只返回整数；`parseFloat(str)` 返回的是一个小数
  ```javascript
  parseInt('100px')       // 100
  parseFloat('12.5em')    // 12.5

  parseInt('12.3')        // 12 （只返回整数部分）
  parseFloat('12.3.4')    // 12.3（the second point stops the reading）
  ```
+ 二者都是从第一个字符开始读取的，若读取到的第一个字符不是 数字，则直接停止（空格会忽略），返回 NaN
  ```javascript
  parseInt('a123')    // NaN (the first symbol stops the process)
  ```
+ `parseInt(str, radix)`，该方法有一个可选的参数，该可选的参数允许按照指定的进制来读数
  ```javascript
  parseInt('0xff', 16)  // 255
  parseInt('ff', 16)    // 255 (without 0x also works)
  ```